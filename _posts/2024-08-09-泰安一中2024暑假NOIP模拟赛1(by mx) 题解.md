> Written by [@Targanzqq](https://www.luogu.com.cn/user/555617)
### 特别鸣谢：
>感谢 hhn ([@Drest](https://www.luogu.com.cn/user/823814)) 对本场比赛的技术支持。
## T1.sum

### 40pts
直接枚举即可，不用多说。

### 80pts
比上一档好写，而且不难想。

设 $f_{0/1,i,j}$ 表示第 $a/b$ 数组前 $i$ 项和为 $j$ 的方案数。我们考虑往里加数。我们可以从 $f_{i,j}$ 转移到 $f_{i+1,j'}$， $j'$ 表示加入新数之后的和。加入新数的范围是 $[l_{i+1},r_{i+1}]$。最后我们根据乘法原理，令 $ans_{i,j}$ 表示 $a$ 选 $i$ 项，$b$ 选 $j$ 项的方案数，则有 $ans_{i,j}=\sum_k f_{i,k}\times f_{j,k}$。假设值域与 $n$ 同阶（上限相同），因此时间复杂度为 $O(n^4)$。

### 100pts
我们考虑一个性质，就是说如果当前集合能转移到一种“相等”的状态，那上一个状态下 $a$ 和 $b$ 已选数的差不会超过值域 $v$。

这个性质还是比较好证的。设当前 $a$ 选了 $i$ 个数，$b$ 选了 $j$ 个数，和为 $k$，那么上一种状态下 $a$ 的和为 $k-a_i$，$b$ 的和为 $k-b_j$，他们的差就是 $a_i-b_j$，这个值显然小于值域。而产生贡献的就是这些值。

这时候有同学可能会说了：如果我们给 $a$ 只放一两个，给 $b$ 放一大堆，那这个差值显然不在这个范围内。但是我们想，最终想要让他们相等，那也是需要把 $a$ 或 $b$ 补到这个范围内的，而先放哪个并不重要。所以产生贡献的就是上面所说的值。

因此我们设 $f_{i,j,k}(k\in [-v,v])$ 设当前 $a$ 选了 $i$ 个数，$b$ 选了 $j$ 个数，**$a$ 的和减去 $b$ 的和**为 $k$。那我们有一种非常“启发式”的策略，就是“谁少了就补谁”。如果 $k>0$，那我们填入一个 $b_i$，否则填入一个 $a_i$。

这时又出现问题了，就是时间复杂度还是 $O(n^4)$ 的。但是我们考虑到，我们要把一个 $f_{i,j,k}$ 赋值到一个和 $k$ 有关的连续段里面。我们把 $f_{i,j}$ 看成一些数组，每个数组里面有 $2*v$ 个值，那就是对其中某个数组进行“区间修改”。由于我们是向后转移的（很多大佬叫它“刷表法”），因此我们在枚举到一个状态后，它已经“接收”到了前面数组转移过来的状态。然后我们需要用这个状态的某个点对后面的状态进行转移，因此我们需要一个单点的查询。

对于这个题，大家一看到“区间修改”“单点查询”，应该不难想到用差分的方式维护。因为在这个题中我们对前者的时间复杂度限制为 $O(1)$，后者为 $O(v)$，因此我们可以用**差分优化 dp**。

具体做法如下：

>我们对于当前状态，如果我们认为它要加入 $a_{i+1}$（因为我们要向 $f_{i+1,j}$ 转移），那么我们可以转移到 $f_{i+1,j,k+[l_{a,i+1},r_{a,i+1}]}$，因此我们令 $f_{i+1,j,k+l_{a,i+1}}$ 加上 $f_{i,j,k}$，然后令 $f_{i+1,j,k+r_{a,i+1}+1}$ 减去 $f_{i,j,k}$。我们对于 $f_{i,j+1}$ 也用差不多的方法。当我们转移过去的状态被遍历到的时候，我们就对新状态 $f_{i',j',[-v,v]}$ 做前缀和即可。

时间复杂度 $O(n^3)$。

## T2.card
这个题我在赛时读错题了，后来断网的时候又不小心点到了刷新，导致我看不到题面（而且我认为自己写出了正解），然后喜提 0pts。

我们先拿到题，可以检测一下有没有“一个字符串内，相邻两个 $1$ 的距离不等于 $m$” 的情况，如果有，直接输出 $-1$。

### 20pts
直接暴力枚举。

### 40pts
做一个状压，设 $f[S][i]$ 表示放进去的字符串的集合,最后一个是第 $i$ 个字符串，每次枚举一个新字符串然后加进去。时间复杂度 $O(2^nn^2)$

### 60pts
除了上面的做法外，直接特判其中两个是否满足条件即可。

### 100pts
前置知识：[欧拉路径](https://www.luogu.com.cn/problem/P7771)。

不会也没关系，原理很简单的。就是说我们在一个图上找一条路径，使得它经过每条边恰好一次。

这样看起来和这个题完全没有关系，但是大家都知道很多和图论无关的题可以~~随便乱转化~~经过推理之后转化为一个类似于图的关系网，而且具有某些性质。

众所周知，这种题难在建图，其余的部分就差不多可以套上一些板子了。我们考虑，这些串本质上一共只有 $m$ 种，因为我们对于某一种长度，只要在后面加上一个 “开头有某些特定数量的 $0$” 的字符串就可以完成转移。因此我们根据这个限制建图。我们一共建 $m$ 个点，然后我们根据上面的要求连边：

> 对于所有字符串，我们令 $(b-f_i)\bmod m$ 号点后面接上 $(b-f_i+|S_i|)\bmod m$ 号点。这样我们就找到了这种状态下序列末尾的状态，从而知道下一个字符串开头有多少个 $0$。边权即为当前字符串的编号，因为我们要根据编号找方案。

接下来我们就可以跑欧拉回路了。首先我们来判定一下这个图有没有欧拉回路（学过小学奥数的同学应该都知道）：

我们到一个点一定经过一条未被访问的入度，并选择一条未被访问的出度离开。然后如果入度比出度多，就可能无法离开（除非它是终点，且入度只比出度多 $1$），如果出度比入度多，那可能会出现冗余的出度（除非它是起点，且出度只比入度多 $1$）。因此我们就根据这个性质判断即可。

> 我们到一个节点后，按照边权由小到大选边，若这条边未被标记，就对它连接的点进行同样操作，并对这条边打上标记，然后当我们回到这个点的时候，就把这条边加进一个栈。最后输出答案。

我们来证明一下这样做的正确性：因为我们到终点返回的时候，所经过的边一定是最后一条边，回到上一个点以后，就相当于“给这个点减少了一条出度”。然而在欧拉回路中（若存在），入度比出度多 $1$ 的点是它成为终点的充分不必要条件，因此它会成为新的终点，这样我们发现它进入了一个递归返回状态，返回到一个还有出度的点，我们就可以再去选新的出度，由于“更小的可能的边”已经被选了，所以这样做一定满足“字典序最小"的要求。

时间复杂度 $O(m+\sum|S|)$。

## T3.triangle
### 30pts
暴力即可（我赛时只会暴力）。
我们考虑到一个性质，就是在一个倒序的序列里选出 $3$ 个数，使得长度为这三个数的边能组成三角形，那么如果相邻的三个数不行，我们去掉其中一个数，换另一个数，那显然也不行。我们设最大的边为 $a_i$，那这种情况下 $a_i\ge a_{i+1}+a_{i+2}$，如果我们把 $a_{i+1}$ 或 $a_{i+2}$ 换成 $a_{i+3}$ 或后面的数，那么上面的式子显然成立。如果我们把 $a_i$ 换成更大的数，那上面的式子显然也成立。

因此我们直接暴力修改，查询时直接从大到小查相邻三个数是否满足条件即可，可以用堆维护。时间复杂度 $O(n^2\log n)$。

### 100pts
我们重新考虑上面的式子，发现我们可以通过维护区间第 $k$ 大的方式解决。维护这种东西会用到主席树（可持久化权值线段树），但是维护起来非常不友好，因此我们考虑继续优化。

上面的式子还有一个性质，就是说如果 $a_i\ge a_{i+1}+a_{i+2}$，则有 $a_i> 2\times a_{i+2}$。我们考虑这样的情况能连续发生几次。我们把这个式子往后推，假设它一直成立，那$a_{i}> 4\times a_{i+4}>8\times a_{i+6}>2^k\times a_{i+2k}$。而 $a_{i+2k}\ge 1$，因此 $k\le V$（$V$ 表示值域）。因此我们让维护线段树的数组改为 $a_{i,x}$，表示第 $i$ 个点第 $x$ 大的数。空间复杂度 $O(n\log V)$。

对于 $built$ 函数，我们搜索到底之后把当前值赋给这个点的最大值，然后向上合并。

对于 $change/modify/update$ 函数，我们直接找到最底层（因为最底层只维护一个值），然后把这个值修改即可，然后向上转移。这样做就不用懒标记。

对于 $query$ 函数，如果这个区间被包含，我们就把这个区间合并到答案数组里，否则转移到下一层。

接下来讲合并。主要使用了二维偏序（归并排序）的方法。

> 我们设两个指针 $i,j$，当前我们要把 $a,b$ 两个有序数组合并为 $c$ 。我们令 $i,j$ 初始为 $1$，如果 $a_i>b_j$，那我们将 $a_i$ 加入，否则将 $b_j$ 加入。如果这个点记录的值大于 $k$，我们就停止加入新的点。这样时间复杂度为 $O(k)$。

两个注意事项：

- 如果当前节点出现了满足条件的情况，那后面的点就没必要加了。这样可以做一个小优化（否则会被卡常数
- 我们在每一次询问后要把 $ans$ 数组情况，每一次合并前要把合并数组清空。

时间复杂度 $O(n\log n\log V)$。

## T4.Seg

我们考虑，如果我们已经选好了一堆线段，且我们想要选到最多的线段，那我们就要让选完一个线段后，它后面可选的线段尽可能多。因此我们就要在可选的范围内，选**右端点最小**的线段，这样就可以满足上面的条件。

### 40pts
直接把 $2^{\frac{n\times(n+1)}{2}}$ 种情况处理出来，然后贪心跑一遍即可。

### 70pts
不会。

### 100pts
还是一道~~啸氢锌~~经典的 dp 题。

我们定义 $f_{i,j}$ 为当前选到一个 $i$ 个数为结尾的区间，已经选了 $j$ 个区间的方案数。我们当前要转移到 $f_{k,j+1}$ 设新选的区间为 $l,r$，接下来开始分类讨论：

- $l\le r\le i<k$ 和 $l\le i\le r<k$，这两种形式无用，前面讨论过了。

- $i<l\le r<k$ 我们要选到 $k$ 如果有这种情况，那选 $k$ 就不优。

- $i<l\le r=k$ 这种情况下一共有 $k-i$个区间，而且我们必须选其中一个，所以我们乘上 $2^{k-i}-1$。

- $i<l\le k<r$ 这种情况下$k$ 的右端点最小，这些区间选不选都行，所以我们乘上 $2^{(n-k)(k-i)}$。

- $i<k<l\le r$ 这种情况下我们选完 $k$ 还可以继续选，不是我们讨论的范围。

因此，转移方程为 $f_{k,j+1}=f_{i,j}*(2^{k-i}-1)*2^{(n-k)(k-i)}$。

边界条件为 $f_{0,0}=1$。

时间复杂度 $O(n^3)$。

### 想要std？
请私信 [Targanzqq ](https://www.luogu.com.cn/user/555617)，但是不把题完全理解就看std是不好的行为qwq
